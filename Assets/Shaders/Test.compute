#include "noiseSimplex.cginc"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel HeightsKernel

RWTexture2D<float4> Result;
Buffer<int> Seed;

float map(float newMin, float newMax, float oldMin, float oldMax, float value)
{
	// inverse lerp
	float inverseLerp;
	if (value < oldMin)
		inverseLerp = oldMin;
	else if (value > oldMax)
		inverseLerp = oldMax;
	else
		inverseLerp = value;

	return lerp(newMin, newMax, inverseLerp);
}

// just like in C functions need to be declared before (above) they are used
static float fractalBrownianMotion(float x, float z, int octaves, float persistence)
{
	float total = 0, frequency = 1, amplitude = 1, maxValue = 0;

	for (int i = 0; i < octaves; i++)
	{
		float2 noiseParams = float2((x + Seed) * frequency, (z + Seed) * frequency);
		float noise = (snoise(noiseParams) + 1) / 2; // we want it to be from 0 to 1
		noise *= amplitude;

		total += noise;
		maxValue += amplitude;
		amplitude *= persistence;
		frequency *= 2;
	}

	return total / maxValue;
}

[numthreads(32,32,1)]
void HeightsKernel(uint3 id : SV_DispatchThreadID)
{
	// constants
	const float smoothBedrock = 0.1, smoothStone = 0.05, smoothDirt = 0.01;
	const float octavesBedrock = 1, octavesStone = 2, octavesDirt = 3;
	const float persistanceBedrock = 0.5, persistanceStone = 0.25, persistanceDirt = 0.5;

	// fractal brownian motions
	float fbmBedrock = fractalBrownianMotion(id.x * smoothBedrock, id.y * smoothBedrock, octavesBedrock, persistanceBedrock);
	float fbmStone = fractalBrownianMotion(id.x * smoothStone, id.y * smoothStone, octavesStone, persistanceStone);
	float fbmDirt = fractalBrownianMotion(id.x * smoothDirt, id.y * smoothDirt, octavesDirt, persistanceDirt);

	// heights
    Result[id.xy] = float4(
		map(0, 15, 0, 1, fbmBedrock) / 255, 
		map(0, 80, 0, 1, fbmStone) / 255, 
		map(0, 90, 0, 1, fbmDirt) / 255, 
		0);
}
